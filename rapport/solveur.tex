% !TeX root = these.tex
\chapter{Solveur}
% le but ici n'est pas d'énumérer toutes les étapes par lesquelles nous sommes passé ainsi que toutes les essais infructué effectué, car ce serait long et inninteressant. Nous allons nous concentrer sur la méthode actuelle utilisée en tantant de justifié son choix. Pour pouvoir expliquer son choix et sont utilisation, nous allons devoir revenir sur les explications plus générale de la programmation par contraites et d'autre thechniques OR (operation research).  Pour plus d'information sur le sujet, nous invitons le lecteur, à XXX, ainsi qu'à la thèse de M qui fut de loins l'ouvrage qui nous a le plus éclairé quand la à la problematique de xx

%On explique d'ou il vient, ce que c'est, par qui ca a été créé

%Après, on explique l'implémentation dans notre logiciel. On en est ou? Les dificulté rencontré? Ce qu'il manque pour que ça soit super cool

%Ensuite, on explique un peu comment ça marche 

%On peut terminer en concluant sur le temps d'apprentissage, les problèmes relatif a la communcation entre client-serveur... et que, dans une prochaine mise à jour, il serait possible d'avoir un truc vachement plus balaise

Pour pouvoir apporter un réel avantage à notre application, comparé à la méthode actuelle de création d'horaire (i.e. manuel), il était nécessaire de lui rajouter une certaine "intelligence". 
Une partie de cette "intelligence" est prise en charge du coté client, qui comme décrit dans une précédente section, se charge d'assister l'utilisateur lors de la création de son horaire.
\newline
\indent
Cependant, ce support est minimaliste et une recherche plus poussée est effectué du coté serveur à l'aide d'outil de programmation par contraintes et de "recherche opérationnelle".  Ce solveur sera ensuite amené à nourrir le solveur minimaliste du coté client et proposer un certain pilotage de ce solveur au travers de l'application cliente. 
\newline
\indent
Pour arriver à ces résultats, nous nous sommes tournés vers des outils de programmation par contraintes et de recherche opérationnelle. 
Pour comprendre notre choix de librairie ainsi que son utilisation, il est important de revenir sur les principe fondamentaux de la programmation par contraintes.


\section{Rappels théorique}

La programmation par contrainte un paradigme de programmation \footnote{paradigme} ayant pour but la résolution de problèmes combinatoire en
descrivant plutot le but recherché que la méthode utilisé, c'est pourquoi la programmation par contrainte es une forme de programmation déclarative.
« Constraint Programming represents one of the closest approaches computer science has yet made to the Holy Grail of programming: the user states the problem, the computer solves it. »
— E. Freuder--citation--

dans le cas qui nous concerne, la problème de création d'horraire, est un cas typique de CSP (Constraint Satisfaction Problem), et comme tout csp peut se définir comme suit:
*** definition formelle ***
Dans notre cas, les variables sont, se qu'on va appeller des "activity", et correspondent à un cours ou à tous type d'activitées pouvant avoir lieu à l'Ephec (il s'agit, dans la méthode traditionnel des cartons physique qui seront manipulé lors de la création d'un horraire.)

Le domaine de valeurs que peuvent prendre ses variables, ses activity, sont un local et une periode de la semaine.  Ca fait un domaine à deux dimentions (Lieu X Periode). Dans l'idéal, il faudrait prendre le choix des professeurs comme troisième dimension, mais ce n'est pas le cas dans notre impémentation actuelle. 

Les contraintes deviennent alors les relation mathématiques reliant les activity.
On a tenté de faire des listes exaustives de ses contraintes, mais seule une sous partie est actuelement pris en compte:



\subsection{Choix de librairies}
Le solveur (celui du coté serveur), est indépendant de tout, absolument tout. Il est écrit en java, et repose sur une librérire de csp. Il réside donc du coté serveur, dans le servelet de l'application, c'est donc le meme pour tout utilisateurs se connectant au  site. Il ressevra l'information et l'enregistrera xxx


Apprès bpc de recherches, cette librairie est de loins la plus adapté et à jours (la dernière version datant du 20 juin, est d'ailleur celle utilisé par le programme).  Ca permetra un dévellopenment du solveur, independament de la bdd ou de l'interface.
Les possibilités de cette librairie combiné à nos choix d'infrastrcuture sont énorme, et à notre grande tristèsse, ne sont pas utilisé au maximum de sa puissance..  seule la surface à pu être implémenté, faute de temps.

\begin{center}
\fbox{\begin{minipage}{\linewidth}
\textbf{Definition 1} $(CSP).$ A constraint satisfaction problem $(CSP)$ is a triple $\Theta$ = (V,D,C), where
\begin{itemize}
\item V = \{$v_1, v_2, ... , v_n$\} is a finite set of variables,
\item D = \{$Dv_1, Dv_2, ... ,Dv_n$ \} is a set of domaines (i.e., $Dv_1$ is a set of possibles ...
\item C = \{$c_1, c_2, ..., c_m$\} is a finite set of constraints restricting the values that the variables can simultaneously take.\\

\textbf{Definition 2} $(assignment)$. Let $\Theta$ be a CSP, an assignment of the variables\\ from V is $\eta$ $	\subseteq$ \{$v$/$a$|$v$ $\in$ V \large \&\normalsize \mbox{} a $\in$ Dv\} where $\forall$ $v$/$a$, $w$/$b$ $\in \eta$ $v$ = w $\Rightarrow$ $a$ = $b$.\\
An element $v$/$a$ of $\in$ means that variable $v$ has assigned value $a$.\\
An assignement is complete if |$\eta$| = |V| ( i.e., all variables are assigned).\\

\textbf{Definition 3} $(solution$ $to$ $CSP).$ A solution to the constraint satisfaction problem $\Theta$ is a complete assignement $\sigma$ of the variables from V that satisfies all the constraints.
\end{itemize}
\end{minipage}}
\end{center}
