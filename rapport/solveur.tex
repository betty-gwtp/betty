% !TeX root = these.tex
\chapter{Solveur}
% le but ici n'est pas d'énumérer toutes les étapes par lesquelles nous sommes passés ainsi que toutes les essais infructueux effectués, car ce serait long et inninteressant. Nous allons nous concentrer sur la méthode actuelle utilisée en tentant de justifier son choix. Pour pouvoir expliquer son choix et son utilisation, nous allons devoir revenir sur les explications plus générales de la programmation par contraites et d'autre techniques OR (operation research).  Pour plus d'information sur le sujet, nous invitons le lecteur, à XXX, ainsi qu'à la thèse de M qui fut de loin l'ouvrage qui nous a le plus éclairé quant la à la problematique de xx
%On explique d'ou il vient, ce que c'est, par qui ca a été cree

%Après, on explique l'implémentation dans notre logiciel. On en est ou? Les dificulté rencontrée? Ce qu'il manque pour que ça soit super cool

%Ensuite, on explique un peu comment ça marche 

%On peut terminer en concluant sur le temps d'apprentissage, les problèmes relatifs a la communcation entre client-serveur... et que, dans une prochaine mise à jour, il serait possible d'avoir un truc vachement plus balaise

Pour pouvoir apporter un réel avantage à notre application, comparé à la méthode actuelle de création d'horaire (i.e. manuel), il était nécessaire de lui rajouter une certaine "intelligence". 
Une partie de cette "intelligence" est prise en charge du coté client, qui comme décrit dans une précédente section, se charge d'assister l'utilisateur lors de la création de son horaire.
\newline
\indent
Cependant, ce support est minimaliste et une recherche plus poussée est effectué du coté serveur à l'aide d'outil de programmation par contraintes et de "recherche opérationnelle".  Ce solveur sera ensuite amené à nourrir le solveur minimaliste du coté client et proposer un certain pilotage de ce solveur au travers de l'application cliente. 
De cette manière, l'application cliente ne dépend pas du serveur pour fonctionner correctement, en effet, si celui-ci venait a être indisponible, les seules concéquences seraient que les propositions offertes par l'application cliente ne seraiennt plus aussi poussées. 
(Il va sans dire que l'option pour créer un horraire complet ne serait plus disponible non plus.)
\newline
\indent
Ce solveur est donc relativement indépendant du reste de l'application, et permettrait, par exemple d'être facilement remplacé par un autre solveur, quasiment, sans aucune modification du reste du code.
Actuellement, ce solveur est écrit en java, et repose sur des librairie d'UniTime\footnote{http://www.UniTime.org}. Il s'agit d'une librairie de programmation par contrainte et de recherche oppérationnelle.
Pour comprendre son utilisation il est indispensable de bien comprendre les concepts de la programmation par contraintes ainsi que les outils qu'aporte cette librairie.

\section{cardre théorique}
\subsection{Recherche Operationnelle}
La recherche opérationnelle (aussi appelée aide à la décision) peut être définie comme l'ensemble des méthodes et techniques rationnelles orientées vers la recherche de la meilleure façon d'opérer des choix en vue d'aboutir au résultat visé ou au meilleur résultat possible\footnote{Larousse 3 volumes, Paris 1966}
La recherche opérationnelle peut donc se faire à l'aide de plusieurs techniques, tel que l'inteligence artificielle, les systèmes experts\footnote{}, ou encore la programmation par contrainte.  C'est par ce dernier "outil" que nous avons finalement abordé notre problème de création d'horaire.
\subsection{Programmation par contrainte}

La programmation par contrainte un paradigme de programmation \footnote{paradigme} ayant pour but la résolution de problèmes combinatoire en
 decrivant plutot le but recherché que la méthode utilisée, c'est pourquoi la programmation par contrainte est une forme de programmation déclarative.
\begin{quote}
« Constraint Programming represents one of the closest approaches computer science has yet made to the Holy Grail of programming: the user states the problem, the computer solves it. »
— E. Freuder
\end{quote}

dans le cas qui nous concerne, la problème de création d'horaire, est un cas typique de CSP\footnote{Constraint Satisfaction Problem}, et comme tout csp peut se définir comme suit:
   
\begin{center}
\fbox{\begin{minipage}{\linewidth}
\textbf{Definition 1} $(CSP).$ Un problème de satisfaction de contraintes $(CSP)$ est un triplet $\Theta$ = (V,D,C), où
\begin{itemize}
\item V = \{$v_1, v_2, ... , v_n$\} est un ensemble fini de variables,
\item D = \{$Dv_1, Dv_2, ... ,Dv_n$ \} est l'ensemble de domaines que ces varriables peuvent prendre, %(i.e., $Dv_1$ is a set of possibles ...
\item C = \{$c_1, c_2, ..., c_m$\} est un ensemble de contraintes, spécifiant les combinaisons de valeurs mutuellement compatibles.\\

\textbf{Definition 2} $(solution$ $d'une$ $CSP).$ Une solution à un problème de satisfaction de contraintes $\Theta$ est l'ensemble des assignations $\sigma$ de toutes les variables de V qui satisfassent toutes les contraintes.
\end{itemize}
\end{minipage}}
\end{center}

%\newline
\indent

Dans le cas de notre problème, les variables seront les Cartons qu'il faut pouvoir déposer dans le tableau, et leur valeurs seront la place à laquelle ils seront déposés.
Leur domaine est donc leur position géographique et temporelle. 
Il s'agit d'un domaine à deux dimensions, nous avons choisi de ne pas prendre en compte une troisième dimension qu'aurait pu être le choix 
d'un professeur pour un cours. 
Il est donc necessaire que chaque "carton" aie préalablement un, et un seul prof, qui lui soitassigné.
Les contraintes n'étant que des relations mathématique entre nos variables, il est aisé de représenter bon nombre de nos contraintes. 
Par exemple pour expliciter qu'un prof ne peut donner deux cours simultanément, notre contrainte s'écrit naturelement :
v1 != v2 où v1 et v2 sont deux cartons d'un meme professeur
% Dans notre cas, les variables sont, ce qu'on va appeller des "activity", et correspondent à un cours ou à tous type d'activités pouvant avoir lieu à l'EPHEC (il s'agit, dans la méthode traditionnelle des cartons physiques qui seront manipulés lors de la création d'un horaire.)
% 
% Le domaine de valeurs que peuvent prendre ses variables, ses activity, sont un local et une periode de la semaine.  Ca fait un domaine à deux dimensions (Lieu X Periode). Dans l'idéal, il faudrait prendre le choix des professeurs comme troisième dimension, mais ce n'est pas le cas dans notre impémentation actuelle. 
% 
% Les contraintes deviennent alors les relations mathématiques reliant les activity.
% On a tenté de faire des listes exaustives de ses contraintes, mais seule une sous partie est actuellement prise en compte:
\subsubsection{Limitations}
La plus part des alogirhmes pour résoudre des CSP, effectuent une recheche systematique à travers toutes les assignations possibles pour les variables du problème. De tel algorithmes garantissent de trouver une solution, si elle éxiste, ou prouver que ce problème ne possède pas de solution.  
Ils commencent à partir du'une solution vide (aucune variable n'est assignée) et effectuent une recherche exhaustive,
lorsqu'une "impasse" survient, ils effectuent alors un retour en arrière ou "backtracking".  
Le plus gros problème d'un tel alogorithme est qu'un mauvais choix d'assignement,
 particulièrement si celui-ci est éffectué au début de la recheche, causera une recherche infructueuse sur l'entièretée d'un sous-arbre. 
%===1. problème np-complet
Le premier problème, c'est que cette facon classique recherche la meilleur soltion, en explorant toutes les possibilitées. Notre problème étant NP-Complet\footnote{Ne peut être résolut en un temps polynomial}, ce qui explique que nos précédents tests avecs des librairies classique furent peut concluante.\newline.
Il est donc necessaire d'avoir recourt à des heuristiques \footnote{}, et meta-heuristique\footnote{Une heuristique d'heuristique ou un ensemble d'heuristiques}, dans les prochaine section, nous décrirons brièvement l'une d'entre elles, à savoir l'Iterative Forward Search qui est celle utilisé pour l'écriture d'UniTime, la librairie que nous utilisons.
\newline
\indent
%=== MPP ========
Le deusième problème, est que cette facon de backtracking, et d'exploration exaustive de noeuds ne permet pas de reprendre une solution parcielle car ..
\newline
\indent
%== Optimisation
Le troisième problème engendré par cette méthode exaustive, c'est qu'elle ne pourra pas fournire une soltion qui ne respecte pas toutes les contraintes, étant donné qu'il ne se déplace que d'états consistant\footnote{} en états consistant. Si un problème n'offre pas de solution, car il y a trop de contraintes, comme dans le cas de la création d'un horaire EPHEC, il ne pourra pas fournir de solution, meme si la "moins pire" des solutions aurait été interessante. Il n'y a donc pas d'optimisation possible.
\newline
\indent
C'est pour cela que nous avons du sortir du modèle classique et utiliser des méthodes dite hybrides, mèlant d'autre méthodes, principalement des heuristiques et métaheuristique, tel que présenté dans les sections suivantes afin de trouver malgré tout une bonne\footnote{peut importe ce que "bonne" signifie} solution, dans des temps accèptables, et permettant de reprendre une solution entamée afin de l'améliorer. \newline
Quant à la question de l'optimisation, nous avons choisi, comme il se fait fréquemment, de séparer nos contraintes en "Hard constraints" et "Soft constraint".  Les "Hard" sont les contraintes sans lesquelles aucune solution n'est envisagable (nous avons par exemple mis la contrainte qu'un prof ne peut pas être à deux endroits différent, comme une "Hard constraint"), et les "Soft Constraint" seront les désidéra et autres préférences, ce sont ces dernières qui feront l'objet d'une optimisation. 
% Dans le cas où une solution est impossible, il sera necessaire de retirer manuellement des "Hard constraint" et de relancer une recherche
\subsubsection{MetaHeursistique, et première approche d'evolution}
Des alogirittmes de recherche local \footnote{mF00}, comme le "min-conflict" ou le tabu search\footnote{} effectuent des recherches, de manière non détemistique, souvant guidée par des heuristique sur des solutions complete, mais pas necessairement fesable.  De tel algorithmes ne guarantisse donc pas de torouver une solution respecant toute les contraintes, mais tante de s'en raprocher. cependante, ces alogoritme peuve être bien plus efficace(en temps de calcul) que les celle systématique. Et pour des problème d'optimisation comme le notre, ils produiront des résultats de bien meilleure qualité.
Il existe d'autres approches qui combinent les recheches locales avec des algorithmes de "backtrackingi", tel que décision repaire, mais nous avons pas exploré ces solutions.

\subsubsection{IFS}
Cette méta-heuristique à été développé par M.Muller dans le cadre de sa thèse et est celle utisé dans sa librairie d'UniTime. 
% Le but n'étant pas d'expliquer en détail le fonctionnement de cette méta-heurisque, 
%==============

\subsection{Choix de librairies}
Notre problème est bien un problème de csp, et la manière de l'aborder, de le traiter ne devrait pas varier d'une librairie à une autre.  Cependant Cette librairieà particulièrement été écrite pour des csp liés à l'établissement d'horaires d'universités, en offrant une certaine facilité d'utilisation et un nombre d'options pour gérer des situations propres à l'enseignement.
Elle est particulièrement adéquate dans son implémentation, car elle se base sur la méta-heuristique ifs, présenté précédement, qui s'avère performante pour ce type de solution.  On a pu l'observer de par nos précédents tests avec les librairies d'OR-tools, et de XX (la lib de P.SHAUS).
\newline
\indent
Un autre avantage de cette librairie, est qu'elle est libre de droit, et régulièrement mise à jours (d'ailleurs, la dernière version, sorti il y a quelques semaine à été incorporé au programme).
% La seule autre possibilité qu'on pourrait imaginer, c'est l'utilisation de l'autre méta-heuristique présentée, Geady search, mais n'ayant trouvé de librairie se basant sur cette métha heuristique, il serait .. % alors que UniTime est complet et fortement maintenu !


\subsection{Impementation et état actuel}
Une fois les principe de CSP compris, l'organisation de notre solveur se simplifie: 
- Nous repésentons nos Variables par la classe "Activity" qui représente un cours, ou tout autre type d'activité.\newline
- Les valeurs que pourront prendre ces variables, sont représentées par la classe "Location" qui représente un local, dont l'ensemble constitue les Domaines de notre CSP.\newline
- Nos contraintes sont représentés par la classe "Ressource", et permettent de représenter instinctivement, qu'une activité necessite telles ou telles "ressources" pour avoir lieu (par exemple, les professeurs, les locaux sont, dans se sens, des "ressources"). Les contraintes Hard seront explicitées par le fait qu'une activité exige une et une ressource. Une contraintes Soft sera représentée par le fait qu'elle necessite une ressource parmi un enssemble (comme un cours d'informatique qui peu avoir lieu dans plusieurs classes) \newline
- Nous avons également une classe appelé "Dependance", qui devrait se charger des contraintes de dépendances entres cours (si un cours doit être raproché ou éloigné d'un autre cours). \newline
Et bien entendu, se trouve dans se même package, le code necessaire pour chercher les informations dans la base de donnée et lancer des recherches selon la configuration demandée.

\indent

Actuellement, il est possible de demander la création d'un horaire complet à partir de l'interface client. Celle-ci sera écrite dans une nouvelle instance, et préviendra (via les notifications) l'utilisateur de la réussite ou de l'echec de celui-ci.  Cette manière de faire, permet de ne pas mettre en conflit cette résolution avec ce qui pourrait se passer du coté client. L'utilisateur peut, pendant une résolution en cours, faire tout ce qu'il veut, et une fois une solution trouvée, celle-ci se placera simplement dans une nouvelle instance.
Pour ce qui est de "nourrir" les informations du sovleur client, ce n'est, actuellement, pas pleinement fonctionnel. L'idée, est de générer plusieurs solutions, 
au fur et à mesure de la construction manuelle, et d'envoyer cela directement dans le Local Storage. Le solveur client, n'a donc qu'a puiser dans ces informations.
En toute logique, ces résultats s'affineront au fur et à mesure que le temps passe, et que la construction manuelle évolue. Cela reste de l'ordre du conseil, étant donné qu'il se peut (si la création manuelle avance vite, si le solveur est trop lent) que cette information ne soit pas toujours rigoureusement à jour, même si l'on privilégie les données les plus récentes.  Ces résultats ne devront donc pas rentrer en concurrence avec ceux du solveur client qui devront avoir le dessus, dans le sens où une action interdite restera interdite et sera toujours marquée en rouge pour l'utilisateur. 
Mais ces informations, devront faire toutes la différence entre un carton vert et rouge, offrant ainsi à l'utilisateur plus des sugestions que des obligations. 

Les possibilités de cette librairie combinées à nos choix d'infrastrcuture sont énormes, et nous sommes persuadés que c'est la meilleure facon de faire. Autant pour la puissance que pourrait offrir ce solveur, mais aussi à la facilité de sa maintenabilité, due à sa grande indépendance face au reste de l'application.
Malheuresement, à l'état actuel, nous n'avons, matérielement, pas eu le temps de l'explorer pleinement, ni d'offir, via l'interface client, suffisament d'options pour controler celui-ci.
Le tout étant en place, et le sujet dé-mystifié, le travail restant est minime pour pouvoir profiter pleinement de cet outil, et nous espérons sincèrement avoir l'ocasion de palier à ce manquement lors d'une future mise-à-jour du programme.
