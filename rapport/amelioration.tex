% !TeX root = these.tex
\chapter{Perspectives}

\section{Possibilités d'amélioration du programme}

\subsection{mode comparaison}
C'était un de nos objectifs principaux; il était question de pouvoir créer à la
voilée les collonnes représentant plusieur professeurs, loacux ou classe, tout
en gardant, pour les lignes, les périodes. Malheureusement le manque de temps à
eu raison de nous, ains qu'un problème fondamentale, à savoire qu'il n'es pas
possible, de rendre une région ne fesant pas partie du DOM (typiquement rajouté
en js, donc d'une manière non-statique) comme étant une région ``dropable''.
Cela n'étant certainement pas impossible, la solution idéal nous est pas encore
connue; probablement qui faudrait rendre l'entièreté de la région contenant le
tableau comme ``dropable'' afin de subdifiser celle ci.. car actuelement ce soit
les ``cases'' qui sont dropable..
\subsection{solveur}
Ce fu également un point assez frustrant, étant donné nos recheches abondante
sur le sujet, et surtout la trouvaille de cette librairire ``miraculeuse'' écrit
par Muller, et qui, en plus d'être en gpl et fortement maintenue (dernière
version date d'il y a 2 semaines), elle nous parrait très performante et d'une
rare adéquoicité.  C'est donc avec bcp de tristesse dans l'ame (:p), qu'on n'en
utilise qu'une fractions de ses possibilité.  C'était tout l'avantage de notre
application (et de sont architectur client-server) et ce n'est pas utilisé a son
full potentiel.  C'est donc la première amérioration que devra subir notre
application, car tout est en place pour pouvoir en tirer un avantage certain.
\subsection{droits}
Un des but de cette architecture était de pouvoir avoir plusieurs compte lié à
un projet, avec des droits différents, imaginons des professeurs qui pouraient
éditer leur désidérata, ou certaine parsonne qui pourait suivre l'évoltion de la
construction de l'horaire sans pour autant avoir les droits de modification.
\subsection{mode hors ligne}
On se base entièrement sur le local storage, les requètes vers le serveur ne
servent qu'a se connecter, charger le projet et enregistrer des modifications.
Actuelement, il est possible de continuer la création d'un horraire chargé en
mémoire sans la necessité d'une connections, cependant, pour pouvoir pleinement
utiliser cette fonctionnalité, il est necessaire de rajouter certaine xxx, tel
qu'une resyncronisation des modifications faite en local avec la bdd lors que la
connection est retrouvée ainsi que la possibilité de reprendre un projet en
cache.
\subsection{upload à partir d'une base de données}
le fichier actuellement utilisé pour l'upload des attributions est le résultat d'une requête SQL. Dans un soucis de clareter et de facilité pour l'utilisateur, il est plus évident de devoir rentrer un fichier manuellement étant donné qu'un autre fichier des locaux doit être également fournis. Pour qu'un upload puisse se faire de manière complète, il faudrait que la liste des locaux avec ce que ceux ci comporte soit également enregister dans une base de données afin de ne pas perdre l'utilisateur sur deux méthodes différentes d'envoi et de pourvoir ainsi garder une certaine cohérence du logiciel.
\subsection{modifications de données}
actuellement il n'est pas possible de modifier toutes les données intervenant
dans l'application (notamment la création d'un prof, local, etc.) Il faudrait donc avoir la possibilité d'ajouter certaines informations directement via l'interface du logiciel, afin de prévenir de tout oubli, ou rajout de dernière minute sur le nombre de classes, etc.

\subsection{Upload de contraintes}
L'idéal serait de permettre à l'utilisateur d'uploader sont fichier de contraintes (sous forme de fichier XML par exemple), ou de pouvoir les entrée manuellement via l'interface. N'étant pas l'objectif de base de notre travail de fin d'étude, celui-ci étant plus orienté sur la programmation par contraintes à proprement parlé et l'intégration de cette programmation dans un outils d'aide à la création d'horaire, et donc l'élaboration de ce logiciel, ceci limite l'utilisateur de l'application aux uniques configuration que nous aurions choisi au préalable. Il faudrait donc dans l'idéal permettre à l'utilisateur de pouvoir manipuler lui même les contraintes.