% !TeX root = these.tex
\chapter{La base de données}

Avant de rentrer dans les détails de la base de données, il est a noter que la vision porté sur celle-ci doit être considéré différemment. L'utilisation d'Hibernate nous a permis de gérer la base de données de manière orienté objet et non plus d'une manière relationnel, la base de données n'est donc plus vue en tant que tel mais plutôt comme un ensemble de ces objets. Hibernate crée aussi des tables de mapping, et a sa propre façon de gérer le relationnelle.

La base de données se veut, délibérément, simple et minimale. Le but étant d'avant tout de manipuler les données liées aux attributions et aux autres données requises par la construction d'un horaire (désideratas, etc.). Nous avons donc évité de manipuler les informations superflus en important celles-ci statiquement dans la base de données. Notre application n'ayant pas pour objectif de modifier ces données.

Par exemple, nous ne nous soucions pas de données propre à l'année, la section, l'implantation, etc.,  Nous nous focalisons uniquement sur les attributions. Les informations qui les composes se doivent d'être séparées en différentes parties (par exemple, les professeurs, les différents groupes, etc.). Certaines données ne sont pas normalisées, ceci n'étant pas requis.

%Xavier, peux tu retravailler cette partie ;-)
Nous pouvons noter un objet plus particulier (correspondant donc à une table de la base de données), l'objet ActivityState. Celui-ci contient l'état d'un carton à un instant donné, c'est à dire, si ce carton est placé, à quel endroit et dans quel ordre le placement a été effectué.  Cette manière de faire nous permettra d'offrir un historique complet de ce qui a été fait en permettant des retours en arrière ou d'offrir une vision statistique de la construction de l'horaire. Nous priviligions de cette manière,  la rapidité et la facilité d'ajout (cette manière ne nécessitant pas de mettre le carton à jour) et prévient également les différentes erreurs pouvant survenir comme une écriture simultanée par différents utilisateurs au sein d'un même projet, d'une perte de connexion, etc.. Ceci étant des perspectives d'avenir du programme et n'étant pour le moment pas prisent en compte.

pour la gestions des contraintes, il est également nécessaires de les sauvegarder, et seulement un set non exostif de contraintes est possibles d'etre enregistré (et traité dans notre programme). Néanmoins, ce set est relativement large et permet de "nommer" la plus part des contraintes.  Il s'agit principalement de "préférences".  Préférences qui pourront être "hard" ou "soft" (un indiquateur est possible pour y mettre plus de grénulosité, mais il n'est actuelement pas pris en compte par notre solveur).  préférence applicable sur un Moment (jour/period) ou sur un(des) local(aux).  préférences dont la sources peuvent être prof, cours, groupe, local.

Avec ca, il est possible de 


